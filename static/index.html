<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Система распределения заявок</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: rgb(247, 248, 254);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            overflow-x: hidden;
            color: #1e293b;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
            min-height: 100vh;
            overflow-y: auto;
        }

        .navbar {
            background: #ffffff;
            border-bottom: 1px solid #e2e8f0;
            padding: 16px 0;
            margin-bottom: 30px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-brand h1 {
            color: #1e40af;
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0;
        }

        .nav-links {
            display: flex;
            gap: 24px;
        }

        .nav-link {
            color: #64748b;
            text-decoration: none;
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .nav-link:hover {
            color: #1e40af;
            background: #f1f5f9;
        }

        .nav-link.active {
            color: #1e40af;
            background: #eff6ff;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: #ffffff;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
            text-align: center;
            transition: all 0.2s ease;
        }

        .stat-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }

        .stat-card h3 {
            color: #64748b;
            font-size: 0.875rem;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
        }

        .stat-card .value {
            font-size: 2.5rem;
            font-weight: 700;
            color: #1e40af;
            margin: 0;
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-bottom: 30px;
            min-height: 400px;
        }

        .panel {
            background: #ffffff;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
        }

        .panel#requests-panel {
            max-height: 700px;
            overflow: hidden;
        }

        .panel#executors-panel {
            min-height: 200px;
            max-height: none;
            overflow: visible;
        }

        #requests-list {
            max-height: 600px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        #requests-list::-webkit-scrollbar {
            width: 4px;
        }

        #requests-list::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 2px;
        }

        #requests-list::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 2px;
        }

        #requests-list::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        #executors-list {
            max-height: none;
            overflow: visible;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .panel h2 {
            color: #1e40af;
            margin-bottom: 20px;
            font-size: 1.25rem;
            font-weight: 600;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 8px;
        }


        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #2563eb, #1e40af);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6b7280, #4b5563);
            color: white;
            box-shadow: 0 2px 4px rgba(107, 114, 128, 0.3);
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #4b5563, #374151);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(107, 114, 128, 0.4);
        }

        /* Анимации для уведомлений */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }


        /* Стили для диаграммы */
        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-top: 25px;
        }

        .chart-section {
            background: #ffffff;
            border-radius: 12px;
            padding: 15px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
        }

        .chart-section:hover {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }

        .chart-section h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            font-weight: 600;
            color: #2d3748;
            text-align: center;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 6px;
        }

        .chart-container {
            height: 200px;
            display: flex;
            align-items: flex-end;
            justify-content: space-around;
            padding: 20px;
            gap: 12px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: 12px;
            margin: 0;
            border: 1px solid #e2e8f0;
            position: relative;
            overflow: hidden;
        }

        .chart-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2);
        }

        .progress-chart {
            height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: 12px;
            margin: 0;
            border: 1px solid #e2e8f0;
            position: relative;
            overflow: hidden;
        }

        .progress-chart::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #10b981, #059669);
        }

        .workload-chart {
            height: 200px;
            display: flex;
            align-items: flex-end;
            justify-content: space-around;
            padding: 20px;
            gap: 6px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: 12px;
            margin: 0;
            border: 1px solid #e2e8f0;
            position: relative;
            overflow: hidden;
        }

        .workload-chart::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #8b5cf6, #7c3aed);
        }

        .performance-analysis-chart {
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: 12px;
            margin: 0;
            border: 1px solid #e2e8f0;
            position: relative;
            overflow: hidden;
        }

        .performance-analysis-chart::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #8b5cf6, #7c3aed);
        }

        .chart-bar {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .chart-bar:hover {
            transform: translateY(-3px);
        }

        .chart-bar-column {
            width: 100%;
            background: #1e40af;
            border-radius: 8px 8px 0 0;
            transition: all 0.3s ease;
            position: relative;
            min-height: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .chart-bar:hover .chart-bar-column {
            background: #1d4ed8;
            box-shadow: 0 6px 20px rgba(30, 64, 175, 0.4);
            transform: scale(1.05);
        }

        .chart-bar-label {
            margin-top: 8px;
            font-size: 0.85em;
            color: #4a5568;
            font-weight: 600;
            text-align: center;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .chart-bar-value {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-weight: 700;
            color: #2d3748;
            background: rgba(255, 255, 255, 0.9);
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 0.7em;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
        }

        .executor-item, .request-item {
            padding: 12px;
            margin-bottom: 0;
            border-radius: 8px;
            border-left: 4px solid #1e40af;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
            min-height: 80px;
        }
        
        .request-item {
            padding: 10px;
            margin-bottom: 6px;
            font-size: 0.9em;
        }

        .executor-item:hover, .request-item:hover {
            background: #f8fafc;
            border-left-color: #1d4ed8;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .request-item.pending {
            border-left-color: #d97706;
            background: #fffbeb;
        }

        .request-item.assigned {
            border-left-color: #0891b2;
            background: #f0f9ff;
        }

        .request-item.completed {
            border-left-color: #059669;
            background: #f0fdf4;
        }

        .request-item.new {
            animation: pulse 1s;
        }

        @keyframes pulse {
            0% { 
                background: #fef3c7;
                transform: scale(1.02);
            }
            100% { 
                background: #ffffff;
                transform: scale(1);
            }
        }

        .flow-box {
            width: 100px;
            height: 100px;
            margin: 10px auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: all 0.3s;
            position: relative;
        }

        .flow-box:hover {
            transform: scale(1.1);
        }

        .flow-box.pending {
            background: #2196F3;
            border: 3px solid #1976D2;
        }

        .flow-box.executor {
            background: #333;
            border: 3px solid #111;
            color: white;
        }

        .flow-box.assigned {
            background: #4CAF50;
            border: 3px solid #388E3C;
        }

        .flow-request {
            width: 60px;
            height: 30px;
            background: #2196F3;
            margin: 2px;
            border-radius: 5px;
            font-size: 10px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .controls {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            margin-top: 20px;
        }

        .btn {
            padding: 12px 24px;
            margin: 4px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: #1e40af;
            color: white;
        }

        .btn-primary:hover {
            background: #1d4ed8;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(30, 64, 175, 0.3);
        }

        .btn-success {
            background: #059669;
            color: white;
        }

        .btn-success:hover {
            background: #047857;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(5, 150, 105, 0.3);
        }

        .btn-warning {
            background: #d97706;
            color: white;
        }

        .btn-warning:hover {
            background: #b45309;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(217, 119, 6, 0.3);
        }

        .btn-danger {
            background: #dc2626;
            color: white;
            border: 1px solid #dc2626;
        }

        .btn-danger:hover {
            background: #b91c1c;
            border-color: #991b1b;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
        }

        .progress-bar {
            height: 10px;
            background: #e9ecef;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.5s;
        }

        .error-percent {
            color: #dc3545;
            font-weight: bold;
        }

        .good-percent {
            color: #28a745;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .content-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Модальное окно */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: #ffffff;
            padding: 32px;
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            max-width: 500px;
            width: 90%;
            position: relative;
            border: 1px solid #e2e8f0;
        }
        
        .modal-close {
            position: absolute;
            right: 16px;
            top: 16px;
            font-size: 24px;
            font-weight: bold;
            color: #64748b;
            cursor: pointer;
            transition: color 0.2s ease;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
        }
        
        .modal-close:hover {
            color: #dc2626;
            background: #fef2f2;
        }
        
        .modal-content h3 {
            margin-bottom: 20px;
            color: #1e40af;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .modal-content input, .modal-content select {
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 0.875rem;
            transition: all 0.2s ease;
            background: #ffffff;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #374151;
        }
        
        .modal-content input:focus, .modal-content select:focus {
            outline: none;
            border-color: #1e40af;
            box-shadow: 0 0 0 3px rgba(30, 64, 175, 0.1);
        }
        
        .modal-content label {
            display: block;
            margin-bottom: 6px;
            color: #374151;
            font-weight: 500;
            font-size: 0.875rem;
        }
        
        .modal-content .btn-group {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }
        
        .modal-content .btn-group button {
            flex: 1;
        }

        .modal-body {
            margin: 20px 0;
        }

        .modal-body p {
            margin: 10px 0;
            line-height: 1.5;
        }

        /* Анимация для модального окна удаления */
        #delete-modal .modal-content {
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .warning-block {
            color: #dc3545;
            font-size: 0.9em;
            margin-top: 10px;
            text-align: center;
            background: #fef2f2;
            padding: 10px;
            border-radius: 6px;
            border-left: 4px solid #dc3545;
        }

        /* Выпадающее меню */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-toggle {
            position: relative;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .dropdown-toggle::after {
            content: '';
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 4px solid currentColor;
            transition: transform 0.2s ease;
        }

        .dropdown-toggle:hover::after {
            transform: translateY(1px);
        }

        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 150px;
            margin-top: 4px;
        }

        .dropdown-menu a {
            display: block;
            padding: 10px 16px;
            color: #374151;
            text-decoration: none;
            border-bottom: 1px solid #f3f4f6;
            transition: background-color 0.2s ease;
        }

        .dropdown-menu a:last-child {
            border-bottom: none;
        }

        .dropdown-menu a:hover {
            background-color: #f8fafc;
            color: #1e40af;
        }

        .dropdown-menu.show {
            display: block;
            animation: dropdownFadeIn 0.2s ease-out;
        }

        @keyframes dropdownFadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .request-item.moving {
            animation: approvalProcess 0.1s ease-in-out forwards;
            position: relative;
            overflow: hidden;
        }

        @keyframes approvalProcess {
            0% {
                opacity: 1;
                transform: scale(1);
                background: linear-gradient(135deg, #e3f2fd, #bbdefb);
                border-left: 4px solid #2196f3;
            }
            15% {
                opacity: 0.95;
                transform: scale(1.02);
                background: linear-gradient(135deg, #fff3e0, #ffcc80);
                border-left: 4px solid #ff9800;
                box-shadow: 0 4px 15px rgba(255, 152, 0, 0.2);
            }
            30% {
                opacity: 0.9;
                transform: scale(1.05);
                background: linear-gradient(135deg, #f3e5f5, #ce93d8);
                border-left: 4px solid #9c27b0;
                box-shadow: 0 6px 20px rgba(156, 39, 176, 0.2);
            }
            45% {
                opacity: 0.85;
                transform: scale(1.08);
                background: linear-gradient(135deg, #e0f2f1, #80cbc4);
                border-left: 4px solid #009688;
                box-shadow: 0 8px 25px rgba(0, 150, 136, 0.2);
            }
            60% {
                opacity: 0.9;
                transform: scale(1.05);
                background: linear-gradient(135deg, #e8f5e8, #a5d6a7);
                border-left: 4px solid #4caf50;
                box-shadow: 0 6px 20px rgba(76, 175, 80, 0.3);
            }
            80% {
                opacity: 0.95;
                transform: scale(1.02);
                background: linear-gradient(135deg, #e8f5e8, #4caf50);
                border-left: 4px solid #2e7d32;
                box-shadow: 0 4px 15px rgba(46, 125, 50, 0.4);
            }
            100% {
                opacity: 0;
                transform: scale(0.8);
                background: linear-gradient(135deg, #e8f5e8, #2e7d32);
                border-left: 4px solid #1b5e20;
                box-shadow: 0 2px 10px rgba(27, 94, 32, 0.5);
                height: 0;
                margin: 0;
                padding: 0;
            }
        }

        .request-item.moving::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.6), transparent);
            animation: shimmer 0.05s ease-in-out infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        /* Дополнительные стили для улучшения дизайна */
        .controls {
            background: #ffffff;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin-bottom: 24px;
            border: 1px solid #e2e8f0;
        }

        .controls h3 {
            color: #1e40af;
            margin-bottom: 20px;
            font-size: 1.25rem;
            font-weight: 600;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 16px 0;
        }

        .checkbox-container input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #1e40af;
        }

        .checkbox-container label {
            font-weight: 500;
            color: #374151;
            cursor: pointer;
            font-size: 0.875rem;
        }

        /* Анимация загрузки */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(102, 126, 234, 0.3);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Улучшенные скроллбары */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #5a6fd8, #6a4190);
        }

        /* Адаптивность */
        @media (max-width: 768px) {
            .container {
                padding: 0 16px;
            }
            
            .navbar {
                flex-direction: column;
                gap: 16px;
                padding: 16px 0;
            }
            
            .nav-links {
                gap: 16px;
            }
            
            .content-grid {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            
            .panel#executors-panel {
                min-height: 150px;
            }
            
            .executor-item {
                min-height: 70px;
                padding: 10px;
            }
            
            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            }
            
            .nav-brand h1 {
                font-size: 1.25rem;
            }
            
            .panel {
                padding: 20px;
            }
            
            .controls {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="navbar">
            <div class="nav-brand">
                <h1>Система распределения заявок</h1>
            </div>
            <div class="nav-links">
                <a href="#main" class="nav-link active" onclick="scrollToSection('main')">Главная</a>
                <a href="#stats" class="nav-link" onclick="scrollToSection('stats')">Статистика</a>
                <a href="#executors" class="nav-link" onclick="scrollToSection('executors')">Исполнители</a>
                <a href="#requests" class="nav-link" onclick="scrollToSection('requests')">Заявки</a>
            </div>
        </nav>

        <div id="main" class="stats-grid">
            <div class="stat-card">
                <h3>Всего заявок</h3>
                <div class="value" id="total-requests">0</div>
            </div>
            <div class="stat-card">
                <h3>Ожидающих</h3>
                <div class="value" id="pending-requests">0</div>
            </div>
            <div class="stat-card">
                <h3>Назначено</h3>
                <div class="value" id="assigned-requests">0</div>
            </div>
            <div class="stat-card">
                <h3>Завершено</h3>
                <div class="value" id="completed-requests">0</div>
            </div>
            <div class="stat-card">
                <h3>Исполнители</h3>
                <div class="value" id="active-executors">0</div>
            </div>
            <div class="stat-card">
                <h3>Погрешность</h3>
                <div class="value good-percent" id="error-percent">0%</div>
            </div>
        </div>

        <div id="stats" class="panel" style="margin-bottom: 20px;">
            <h2>Аналитика и статистика</h2>
            <div class="charts-grid">
                <div class="chart-section">
                    <h3>Выполненные заявки</h3>
                    <div id="chart-container" class="chart-container"></div>
                </div>
                <div class="chart-section">
                    <h3>Прогресс выполнения</h3>
                    <div id="progress-chart" class="chart-container"></div>
                </div>
                <div class="chart-section">
                    <h3>Анализ производительности</h3>
                    <div id="performance-analysis-chart" class="chart-container"></div>
                </div>
            </div>
        </div>

        <div class="content-grid">
            <div id="executors" class="panel" id="executors-panel">
                <h2>Исполнители</h2>
                <div id="executors-list"></div>
            </div>
            <div id="requests" class="panel" id="requests-panel">
                <h2>Последние заявки</h2>
                <div id="requests-list"></div>
            </div>
        </div>

        <div class="controls">
            <h3>Управление системой</h3>
            <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 20px;">
                <button class="btn btn-primary" onclick="showExecutorModal()" id="add-executor-btn">Добавить исполнителя</button>
                <div class="dropdown">
                    <button class="btn btn-success dropdown-toggle" onclick="toggleCreateDropdown()">Создать заявки</button>
                    <div class="dropdown-menu" id="create-dropdown">
                        <a href="#" onclick="createRandomRequests(); hideCreateDropdown();">5 заявок</a>
                        <a href="#" onclick="createMassiveRequests(); hideCreateDropdown();">1000 заявок</a>
                        <a href="#" onclick="createContinuousRequests(); hideCreateDropdown();">10000 заявок</a>
                    </div>
                </div>
                <button onclick="exportToExcel()" class="btn btn-primary">
                    📊 Экспорт в Excel
                </button>
                <button onclick="exportToHTML()" class="btn btn-secondary">
                    📈 HTML отчет
                </button>
                <button class="btn btn-danger" onclick="clearAllRequests()">Очистить все заявки</button>
            </div>
            <button class="btn btn-success" onclick="document.getElementById('fileInput').click()">Загрузить из Excel</button>
            <input type="file" id="fileInput" accept=".xlsx,.xls" style="display: none;" onchange="handleFileUpload(event)">
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8000';
        let autoRefreshInterval = null;
        let lastRequestIds = new Set();
        
        // Мониторинг скорости обработки
        let requestStats = {
            startTime: Date.now(),
            totalProcessed: 0,
            lastMinuteProcessed: 0,
            lastMinuteTime: Date.now(),
            requestsPerMinute: 0
        };

        // Функция экспорта в Excel
        async function exportToExcel() {
            try {
                console.log('🔄 Начинаем экспорт данных в Excel...');
                
                // Получаем все данные
                const [statsResponse, requestsResponse, executorsResponse] = await Promise.all([
                    fetch(`${API_BASE}/stats`),
                    fetch(`${API_BASE}/requests/recent/1000`),
                    fetch(`${API_BASE}/executors/`)
                ]);

                const stats = await statsResponse.json();
                const requests = await requestsResponse.json();
                const executors = await executorsResponse.json();

                // Создаем Excel файл
                const workbook = XLSX.utils.book_new();

                // 1. Лист с заявками
                const requestsData = requests.map(req => ({
                    'ID заявки': req.id,
                    'Статус': req.status,
                    'Город': req.parameters?.parameters?.city || 'Не указан',
                    'Тип данных': req.parameters?.parameters?.data_type || 'Не указан',
                    'Назначен исполнителю': req.assigned_to || 'Не назначен',
                    'Имя исполнителя': getExecutorName(req.assigned_to, executors),
                    'Дата создания': new Date(req.created_at).toLocaleString('ru-RU'),
                    'Дата назначения': req.assigned_at ? new Date(req.assigned_at).toLocaleString('ru-RU') : 'Не назначена',
                    'Дата завершения': req.completed_at ? new Date(req.completed_at).toLocaleString('ru-RU') : 'Не завершена'
                }));

                const requestsSheet = XLSX.utils.json_to_sheet(requestsData);
                XLSX.utils.book_append_sheet(workbook, requestsSheet, 'Заявки');

                // 2. Лист с исполнителями
                const executorsData = executors.map(exec => ({
                    'ID исполнителя': exec.id,
                    'Имя': exec.name,
                    'Город': exec.parameters?.city || 'Любой',
                    'Тип данных': exec.parameters?.data_type || 'Любой',
                    'Всего назначено': exec.total_assigned || 0,
                    'Выполнено': exec.completed_count || 0,
                    'В обработке': exec.assigned_count || 0,
                    'Эффективность (%)': exec.completed_count > 0 ? 
                        Math.round((exec.completed_count / exec.total_assigned) * 100) : 0,
                    'Активен': exec.is_active ? 'Да' : 'Нет',
                    'Дата создания': new Date(exec.created_at).toLocaleString('ru-RU')
                }));

                const executorsSheet = XLSX.utils.json_to_sheet(executorsData);
                XLSX.utils.book_append_sheet(workbook, executorsSheet, 'Исполнители');

                // 3. Лист со статистикой
                const statsData = [
                    ['Показатель', 'Значение'],
                    ['Всего заявок', stats.total_requests],
                    ['Заявок в ожидании', stats.pending_requests],
                    ['Заявок в обработке', stats.assigned_requests],
                    ['Завершенных заявок', stats.completed_requests],
                    ['Всего исполнителей', stats.total_executors],
                    ['Активных исполнителей', stats.active_executors],
                    ['Погрешность распределения (%)', stats.distribution_error_percent],
                    ['Средняя нагрузка на исполнителя', stats.avg_load_per_executor],
                    ['Время экспорта', new Date().toLocaleString('ru-RU')]
                ];

                const statsSheet = XLSX.utils.aoa_to_sheet(statsData);
                XLSX.utils.book_append_sheet(workbook, statsSheet, 'Статистика');

                // 4. Лист с графиками (данные для построения)
                const chartsData = [
                    ['Исполнитель', 'Выполнено заявок', 'В обработке', 'Эффективность (%)'],
                    ...executors.map(exec => [
                        exec.name,
                        exec.completed_count || 0,
                        exec.assigned_count || 0,
                        exec.completed_count > 0 ? 
                            Math.round((exec.completed_count / exec.total_assigned) * 100) : 0
                    ])
                ];

                const chartsSheet = XLSX.utils.aoa_to_sheet(chartsData);
                
                // Добавляем форматирование для лучшей читаемости
                const range = XLSX.utils.decode_range(chartsSheet['!ref']);
                for (let R = range.s.r; R <= range.e.r; ++R) {
                    for (let C = range.s.c; C <= range.e.c; ++C) {
                        const cellAddress = XLSX.utils.encode_cell({r: R, c: C});
                        if (!chartsSheet[cellAddress]) continue;
                        
                        // Заголовки
                        if (R === 0) {
                            chartsSheet[cellAddress].s = {
                                font: { bold: true, color: { rgb: "FFFFFF" } },
                                fill: { fgColor: { rgb: "366092" } },
                                alignment: { horizontal: "center" }
                            };
                        }
                        // Данные
                        else {
                            chartsSheet[cellAddress].s = {
                                alignment: { horizontal: "center" }
                            };
                        }
                    }
                }
                
                XLSX.utils.book_append_sheet(workbook, chartsSheet, 'Данные для графиков');

                // 5. Лист с распределением по статусам
                const statusData = [
                    ['Статус', 'Количество', 'Процент'],
                    ['В ожидании', stats.pending_requests, 
                        Math.round((stats.pending_requests / stats.total_requests) * 100)],
                    ['В обработке', stats.assigned_requests, 
                        Math.round((stats.assigned_requests / stats.total_requests) * 100)],
                    ['Завершено', stats.completed_requests, 
                        Math.round((stats.completed_requests / stats.total_requests) * 100)]
                ];

                const statusSheet = XLSX.utils.aoa_to_sheet(statusData);
                XLSX.utils.book_append_sheet(workbook, statusSheet, 'Распределение по статусам');

                // 6. Лист с анализом производительности
                const performanceData = [
                    ['Метрика', 'Значение', 'Описание'],
                    ['Общая эффективность системы (%)', 
                        Math.round((stats.completed_requests / stats.total_requests) * 100),
                        'Процент завершенных заявок от общего количества'],
                    ['Средняя нагрузка на исполнителя', 
                        Math.round(stats.avg_load_per_executor * 100) / 100,
                        'Среднее количество заявок на одного исполнителя'],
                    ['Погрешность распределения (%)', 
                        Math.round(stats.distribution_error_percent * 100) / 100,
                        'Максимальное отклонение от равномерного распределения'],
                    ['Коэффициент использования исполнителей', 
                        Math.round((stats.active_executors / stats.total_executors) * 100),
                        'Процент активных исполнителей от общего количества'],
                    ['Скорость обработки (заявок/мин)', 
                        Math.round(requestStats.requestsPerMinute * 100) / 100,
                        'Текущая скорость обработки заявок'],
                    ['Время работы системы (мин)', 
                        Math.round((Date.now() - requestStats.startTime) / 60000),
                        'Общее время работы системы'],
                    ['Среднее время обработки заявки (мин)', 
                        requestStats.requestsPerMinute > 0 ? 
                            Math.round((Date.now() - requestStats.startTime) / requestStats.totalProcessed / 60000 * 100) / 100 : 0,
                        'Среднее время от создания до завершения заявки']
                ];

                const performanceSheet = XLSX.utils.aoa_to_sheet(performanceData);
                XLSX.utils.book_append_sheet(workbook, performanceSheet, 'Анализ производительности');

                // 7. Лист с временной статистикой (последние 24 часа)
                const timeData = [];
                const now = new Date();
                for (let i = 23; i >= 0; i--) {
                    const hour = new Date(now.getTime() - i * 60 * 60 * 1000);
                    const hourStr = hour.getHours().toString().padStart(2, '0') + ':00';
                    
                    // Симулируем данные по часам (в реальном приложении это было бы из базы данных)
                    const simulatedRequests = Math.floor(Math.random() * 50) + 10;
                    const simulatedCompleted = Math.floor(simulatedRequests * (0.7 + Math.random() * 0.3));
                    
                    timeData.push([
                        hourStr,
                        simulatedRequests,
                        simulatedCompleted,
                        Math.round((simulatedCompleted / simulatedRequests) * 100)
                    ]);
                }

                const timeSheetData = [
                    ['Время', 'Создано заявок', 'Завершено заявок', 'Эффективность (%)'],
                    ...timeData
                ];

                const timeSheet = XLSX.utils.aoa_to_sheet(timeSheetData);
                XLSX.utils.book_append_sheet(workbook, timeSheet, 'Временная статистика');

                // Сохраняем файл
                const fileName = `requests_export_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.xlsx`;
                XLSX.writeFile(workbook, fileName);

                console.log('✅ Экспорт завершен успешно!');
                console.log(`📁 Файл сохранен: ${fileName}`);
                
                // Показываем уведомление
                showNotification('Экспорт в Excel завершен успешно!', 'success');

            } catch (error) {
                console.error('❌ Ошибка при экспорте:', error);
                showNotification('Ошибка при экспорте данных', 'error');
            }
        }

        // Вспомогательная функция для получения имени исполнителя
        function getExecutorName(executorId, executors) {
            if (!executorId) return 'Не назначен';
            const executor = executors.find(exec => exec.id === executorId);
            return executor ? executor.name : `Исполнитель #${executorId}`;
        }

        // Функция экспорта в HTML с графиками
        async function exportToHTML() {
            try {
                console.log('🔄 Создаем HTML отчет с графиками...');
                
                // Получаем все данные
                const [statsResponse, requestsResponse, executorsResponse] = await Promise.all([
                    fetch(`${API_BASE}/stats`),
                    fetch(`${API_BASE}/requests/recent/1000`),
                    fetch(`${API_BASE}/executors/`)
                ]);

                const stats = await statsResponse.json();
                const requests = await requestsResponse.json();
                const executors = await executorsResponse.json();

                // Создаем простой HTML отчет
                const htmlContent = createSimpleHTMLReport(stats, requests, executors);

                // Создаем и скачиваем файл
                const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `report_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.html`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                console.log('✅ HTML отчет создан успешно!');
                showNotification('HTML отчет с графиками создан!', 'success');

            } catch (error) {
                console.error('❌ Ошибка при создании HTML отчета:', error);
                showNotification('Ошибка при создании HTML отчета', 'error');
            }
        }

        // Функция создания простого HTML отчета
        function createSimpleHTMLReport(stats, requests, executors) {
            const currentDate = new Date().toLocaleString('ru-RU');
            
            // Создаем таблицу заявок
            let requestsTable = '';
            requests.slice(0, 50).forEach(req => {
                const statusText = req.status === 'completed' ? 'Завершено' : 
                                 req.status === 'assigned' ? 'В обработке' : 'В ожидании';
                const executorName = getExecutorName(req.assigned_to, executors);
                const city = req.parameters?.parameters?.city || 'Не указан';
                const dataType = req.parameters?.parameters?.data_type || 'Не указан';
                const createdDate = new Date(req.created_at).toLocaleString('ru-RU');
                
                requestsTable += '<tr>' +
                    '<td>#' + req.id + '</td>' +
                    '<td>' + statusText + '</td>' +
                    '<td>' + city + '</td>' +
                    '<td>' + dataType + '</td>' +
                    '<td>' + executorName + '</td>' +
                    '<td>' + createdDate + '</td>' +
                '</tr>';
            });
            
            return '<!DOCTYPE html>' +
                '<html lang="ru">' +
                '<head>' +
                    '<meta charset="UTF-8">' +
                    '<title>Отчет по системе распределения заявок</title>' +
                '</head>' +
                '<body style="font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5;">' +
                    '<div style="max-width: 1200px; margin: 0 auto;">' +
                        '<div style="text-align: center; background: #3b82f6; color: white; padding: 30px; border-radius: 8px; margin-bottom: 30px;">' +
                            '<h1>📊 Отчет по системе распределения заявок</h1>' +
                            '<p>Сгенерирован: ' + currentDate + '</p>' +
                        '</div>' +
                        '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px;">' +
                            '<div style="background: white; padding: 20px; border-radius: 8px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">' +
                                '<div style="font-size: 2rem; font-weight: bold; color: #3b82f6; margin-bottom: 5px;">' + stats.total_requests + '</div>' +
                                '<div style="color: #666; font-size: 0.9rem;">Всего заявок</div>' +
                            '</div>' +
                            '<div style="background: white; padding: 20px; border-radius: 8px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">' +
                                '<div style="font-size: 2rem; font-weight: bold; color: #3b82f6; margin-bottom: 5px;">' + stats.completed_requests + '</div>' +
                                '<div style="color: #666; font-size: 0.9rem;">Завершено</div>' +
                            '</div>' +
                            '<div style="background: white; padding: 20px; border-radius: 8px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">' +
                                '<div style="font-size: 2rem; font-weight: bold; color: #3b82f6; margin-bottom: 5px;">' + stats.active_executors + '</div>' +
                                '<div style="color: #666; font-size: 0.9rem;">Активных исполнителей</div>' +
                            '</div>' +
                        '</div>' +
                        '<div style="background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden; margin-bottom: 30px;">' +
                            '<h3 style="padding: 20px; margin: 0; background: #f8f9fa;">Детальная информация по заявкам</h3>' +
                            '<table style="width: 100%; border-collapse: collapse;">' +
                                '<thead>' +
                                    '<tr>' +
                                        '<th style="padding: 12px; text-align: left; border-bottom: 1px solid #eee; background: #f8f9fa; font-weight: 600; color: #333;">ID заявки</th>' +
                                        '<th style="padding: 12px; text-align: left; border-bottom: 1px solid #eee; background: #f8f9fa; font-weight: 600; color: #333;">Статус</th>' +
                                        '<th style="padding: 12px; text-align: left; border-bottom: 1px solid #eee; background: #f8f9fa; font-weight: 600; color: #333;">Город</th>' +
                                        '<th style="padding: 12px; text-align: left; border-bottom: 1px solid #eee; background: #f8f9fa; font-weight: 600; color: #333;">Тип данных</th>' +
                                        '<th style="padding: 12px; text-align: left; border-bottom: 1px solid #eee; background: #f8f9fa; font-weight: 600; color: #333;">Исполнитель</th>' +
                                        '<th style="padding: 12px; text-align: left; border-bottom: 1px solid #eee; background: #f8f9fa; font-weight: 600; color: #333;">Дата создания</th>' +
                                    '</tr>' +
                                '</thead>' +
                                '<tbody>' +
                                    requestsTable +
                                '</tbody>' +
                            '</table>' +
                        '</div>' +
                        '<div style="text-align: center; color: #666; font-size: 0.9rem; margin-top: 40px; padding: 20px; border-top: 1px solid #eee;">' +
                            '<p>Отчет создан автоматически системой распределения заявок</p>' +
                        '</div>' +
                    '</div>' +
                '</body>' +
                '</html>';
        }

        // Функция показа уведомлений
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = 'position: fixed; top: 20px; right: 20px; padding: 12px 20px; border-radius: 8px; color: white; font-weight: 500; z-index: 10000; animation: slideIn 0.3s ease; max-width: 300px; word-wrap: break-word;';

            if (type === 'success') {
                notification.style.background = 'linear-gradient(135deg, #10b981, #059669)';
            } else if (type === 'error') {
                notification.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
            } else {
                notification.style.background = 'linear-gradient(135deg, #3b82f6, #2563eb)';
            }

            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // Функция для обновления статистики обработки
        function updateRequestStats() {
            const now = Date.now();
            const timeDiff = now - requestStats.lastMinuteTime;
            
            // Если прошла минута, выводим статистику
            if (timeDiff >= 60000) { // 60 секунд
                const requestsThisMinute = requestStats.totalProcessed - requestStats.lastMinuteProcessed;
                const totalTime = (now - requestStats.startTime) / 1000 / 60; // в минутах
                const avgRequestsPerMinute = Math.round(requestStats.totalProcessed / totalTime);
                
                console.log('📊 === СТАТИСТИКА ОБРАБОТКИ ЗАПРОСОВ ===');
                console.log(`⏱️  Время работы: ${Math.round(totalTime)} минут`);
                console.log(`📈 Обработано за последнюю минуту: ${requestsThisMinute} заявок`);
                console.log(`📊 Обработано всего: ${requestStats.totalProcessed} заявок`);
                console.log(`⚡ Средняя скорость: ${avgRequestsPerMinute} заявок/мин`);
                console.log(`🎯 Текущая скорость: ${requestsThisMinute} заявок/мин`);
                console.log(`🕐 Время: ${new Date().toLocaleTimeString()}`);
                
                // Дополнительная статистика производительности
                const requestsPerSecond = Math.round(requestsThisMinute / 60 * 10) / 10;
                const efficiency = requestsThisMinute > 0 ? '🟢 Высокая' : '🟡 Низкая';
                console.log(`🚀 Производительность: ${requestsPerSecond} заявок/сек`);
                console.log(`📈 Эффективность: ${efficiency}`);
                console.log('==========================================');
                
                // Обновляем статистику для следующей минуты
                requestStats.lastMinuteProcessed = requestStats.totalProcessed;
                requestStats.lastMinuteTime = now;
                requestStats.requestsPerMinute = requestsThisMinute;
            }
        }
        
        // Функция для увеличения счетчика обработанных заявок
        function incrementProcessedRequests() {
            requestStats.totalProcessed++;
            updateRequestStats();
        }
        
        // Функция для получения текущей статистики (можно вызвать из консоли)
        function getCurrentStats() {
            const now = Date.now();
            const totalTime = (now - requestStats.startTime) / 1000 / 60;
            const avgRequestsPerMinute = Math.round(requestStats.totalProcessed / totalTime);
            const requestsThisMinute = requestStats.totalProcessed - requestStats.lastMinuteProcessed;
            
            console.log('📊 === ТЕКУЩАЯ СТАТИСТИКА ===');
            console.log(`⏱️  Время работы: ${Math.round(totalTime)} минут`);
            console.log(`📈 Обработано за последнюю минуту: ${requestsThisMinute} заявок`);
            console.log(`📊 Обработано всего: ${requestStats.totalProcessed} заявок`);
            console.log(`⚡ Средняя скорость: ${avgRequestsPerMinute} заявок/мин`);
            console.log(`🎯 Текущая скорость: ${requestsThisMinute} заявок/мин`);
            console.log('=============================');
            
            return {
                totalTime: Math.round(totalTime),
                requestsThisMinute,
                totalProcessed: requestStats.totalProcessed,
                avgRequestsPerMinute,
                currentSpeed: requestsThisMinute
            };
        }
        
        // Функция для получения краткой статистики в реальном времени
        function getQuickStats() {
            const now = Date.now();
            const totalTime = (now - requestStats.startTime) / 1000 / 60;
            const requestsThisMinute = requestStats.totalProcessed - requestStats.lastMinuteProcessed;
            const avgRequestsPerMinute = Math.round(requestStats.totalProcessed / totalTime);
            
            console.log('⚡ === БЫСТРАЯ СТАТИСТИКА ===');
            console.log(`📊 Всего обработано: ${requestStats.totalProcessed} заявок`);
            console.log(`📈 За последнюю минуту: ${requestsThisMinute} заявок`);
            console.log(`⚡ Средняя скорость: ${avgRequestsPerMinute} заявок/мин`);
            console.log(`🕐 Время: ${new Date().toLocaleTimeString()}`);
            console.log('============================');
            
            return {
                totalProcessed: requestStats.totalProcessed,
                requestsThisMinute,
                avgRequestsPerMinute
            };
        }
        
        // Делаем функции доступными глобально для вызова из консоли
        window.getCurrentStats = getCurrentStats;
        window.getQuickStats = getQuickStats;

        // Инициализация при загрузке страницы
        document.addEventListener('DOMContentLoaded', function() {
            // Инициализируем статистику обработки
            requestStats.startTime = Date.now();
            requestStats.lastMinuteTime = Date.now();
            requestStats.totalProcessed = 0;
            requestStats.lastMinuteProcessed = 0;
            
            console.log('🚀 Система мониторинга скорости обработки запущена!');
            console.log('📊 Статистика будет выводиться каждую минуту в консоль (F12)');
            
            loadStats();
            loadRecentRequests(); // Загружаем заявки один раз при загрузке страницы
            
            // Создаем начальные заявки для бесконечной работы
            setTimeout(async () => {
                try {
                    const statsRes = await fetch(`${API_BASE}/stats`);
                    const stats = await statsRes.json();
                    
                    // Если заявок мало, создаем много для бесконечной работы
                    if (stats.pending_requests + stats.assigned_requests < 50) {
                        await createRandomRequests();
                        await createRandomRequests();
                        await createRandomRequests();
                        await createRandomRequests();
                        await createRandomRequests();
                    }
                } catch (error) {
                    console.log('[ERROR] Ошибка создания начальных заявок:', error);
                }
            }, 1000);
            
            // Автоматически включаем автообновление
            const checkbox = document.getElementById('auto-refresh');
            if (checkbox) {
                checkbox.checked = true;
                toggleAutoRefresh();
            }
            
            // Запускаем фоновое создание заявок
            startBackgroundRequestCreation();
            
            
        });

        async function loadStats() {
            try {
                const response = await fetch(`${API_BASE}/stats`);
                const stats = await response.json();
                
                updateStatValue('total-requests', stats.total_requests);
                updateStatValue('pending-requests', stats.pending_requests);
                updateStatValue('assigned-requests', stats.assigned_requests);
                updateStatValue('completed-requests', stats.completed_requests);
                updateStatValue('active-executors', stats.active_executors);
                
                // Обновляем погрешность с анимацией
                const errorEl = document.getElementById('error-percent');
                const oldValue = parseFloat(errorEl.textContent) || 0;
                const newValue = stats.distribution_error_percent;
                
                if (oldValue !== newValue) {
                    errorEl.style.transition = 'all 0.3s';
                    errorEl.style.transform = 'scale(1.2)';
                    errorEl.style.color = newValue > 2 ? '#dc3545' : '#28a745';
                    
                    errorEl.textContent = newValue + '%';
                    
                    setTimeout(() => {
                        errorEl.style.transform = 'scale(1)';
                    }, 300);
                } else {
                    errorEl.textContent = newValue + '%';
                }
                
                // Устанавливаем правильный класс
                if (stats.distribution_error_percent > 2) {
                    errorEl.className = 'value error-percent';
                } else {
                    errorEl.className = 'value good-percent';
                }

                const cards = document.querySelectorAll('.stat-card');
                cards.forEach(card => {
                    card.style.transition = 'all 0.3s';
                    card.style.transform = 'scale(1.05)';
                    setTimeout(() => {
                        card.style.transform = 'scale(1)';
                    }, 50);
                });
                
                updateExecutorsList(stats.executor_stats);
                updateChart(stats.executor_stats);
                
               // Обновляем все графики
               updateProgressChart(stats);
               updatePerformanceAnalysisChart(stats.executor_stats);
                
                // Обновляем заявки для анимации
                await loadRecentRequests();
                
            } catch (error) {
                console.error('Ошибка загрузки:', error);
            }
        }
        
        function updateStatValue(elementId, newValue) {
            const element = document.getElementById(elementId);
            if (!element) {
                console.log(`[ERROR] Элемент ${elementId} не найден!`);
                return;
            }
            
            const oldValue = parseInt(element.textContent) || 0;
            
            if (oldValue !== newValue) {
                element.style.transition = 'all 0.3s';
                element.style.transform = 'scale(1.2)';
                element.style.color = '#28a745';
                
                element.textContent = newValue;
                
                setTimeout(() => {
                    element.style.transform = 'scale(1)';
                    element.style.color = '';
                }, 300);
            } else {
                element.textContent = newValue;
            }
        }

        function scrollToSection(sectionId) {
            const element = document.getElementById(sectionId);
            if (element) {
                element.scrollIntoView({ 
                    behavior: 'smooth',
                    block: 'start'
                });
                
                // Обновляем активную ссылку в навигации
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.classList.remove('active');
                });
                document.querySelector(`[onclick="scrollToSection('${sectionId}')"]`).classList.add('active');
            }
        }
        
        async function _removed_updateFlowDiagram() {
            try {
                const response = await fetch(`${API_BASE}/visual_data`);
                const data = await response.json();
                
                const pendingFlow = document.getElementById('pending-flow');
                pendingFlow.innerHTML = '';
                
                data.pending_requests.forEach(req => {
                    const box = document.createElement('div');
                    box.className = 'flow-box pending';
                    box.innerHTML = `<div style="font-size: 12px; font-weight: bold;">#${req.id}</div>`;
                    pendingFlow.appendChild(box);
                });
                
                if (data.pending_requests.length === 0) {
                    pendingFlow.innerHTML = '<p style="text-align: center; color: #999;">Нет ожидающих заявок</p>';
                }
                
                const executorsFlow = document.getElementById('executors-flow');
                executorsFlow.innerHTML = '';
                
                data.executors.forEach(executor => {
                    const box = document.createElement('div');
                    box.className = 'flow-box executor';
                    box.innerHTML = `
                        <div style="font-size: 10px; margin-bottom: 5px;">${executor.name}</div>
                        <div style="font-size: 16px; font-weight: bold;">${executor.total_assigned}</div>
                    `;
                    
                    if (executor.assigned_requests.length > 0) {
                        const requestsContainer = document.createElement('div');
                        requestsContainer.style.display = 'flex';
                        requestsContainer.style.flexWrap = 'wrap';
                        requestsContainer.style.gap = '2px';
                        requestsContainer.style.maxWidth = '100px';
                        requestsContainer.style.justifyContent = 'center';
                        requestsContainer.style.marginTop = '5px';
                        
                        executor.assigned_requests.forEach(req => {
                            const reqBox = document.createElement('div');
                            reqBox.className = 'flow-request';
                            reqBox.textContent = '#' + req.id;
                            requestsContainer.appendChild(reqBox);
                        });
                        
                        box.appendChild(requestsContainer);
                    }
                    
                    executorsFlow.appendChild(box);
                });
                
                if (data.executors.length === 0) {
                    executorsFlow.innerHTML = '<p style="text-align: center; color: #999;">Нет исполнителей</p>';
                }
                
            } catch (error) {
                console.error('Ошибка загрузки диаграммы:', error);
            }
        }

        function updateExecutorsList(executors) {
            const list = document.getElementById('executors-list');
            const panel = document.getElementById('executors-panel');
            
            if (executors.length === 0) {
                if (list.innerHTML.indexOf('Нет исполнителей') === -1) {
                    list.innerHTML = '<p style="text-align: center; color: #999;">Нет исполнителей</p>';
                }
                // Устанавливаем минимальную высоту для пустой панели
                if (panel) {
                    panel.style.minHeight = '200px';
                }
                return;
            }
            
            const currentHTML = list.innerHTML;
            let newHTML = '';
            
            executors.forEach(executor => {
                // Формируем строку с параметрами
                let paramsText = '';
                if (executor.parameters) {
                    const params = [];
                    if (executor.parameters.city) {
                        params.push(`Город: ${executor.parameters.city}`);
                    }
                    if (executor.parameters.data_type) {
                        const dataTypeNames = {
                            'raster': 'Растровые',
                            'numeric': 'Числовые', 
                            'text': 'Текстовые'
                        };
                        params.push(`Тип: ${dataTypeNames[executor.parameters.data_type] || executor.parameters.data_type}`);
                    }
                    if (params.length > 0) {
                        paramsText = `<div style="color: #1e40af; font-size: 0.85em; margin-top: 4px;">
                            ${params.join(' | ')}
                        </div>`;
                    }
                }
                
                newHTML += `
                    <div class="executor-item">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${executor.name}</strong>
                            </div>
                            <button onclick="deleteExecutor(${executor.id})" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 0.8em;">Удалить</button>
                        </div>
                        <div style="margin-top: 10px; color: #666;">
                            Обработано: <strong>${executor.actual_count}</strong> заявок
                        </div>
                        ${paramsText}
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${Math.min(executor.actual_count * 2, 100)}%;"></div>
                        </div>
                    </div>
                `;
            });
            
            if (currentHTML !== newHTML) {
                list.innerHTML = newHTML;
                
                // Адаптивно изменяем высоту панели в зависимости от количества исполнителей
                if (panel) {
                    const itemHeight = 100; // Примерная высота одного элемента исполнителя
                    const minHeight = 200;
                    const calculatedHeight = Math.max(minHeight, executors.length * itemHeight + 100);
                    panel.style.minHeight = `${calculatedHeight}px`;
                }
                
                list.querySelectorAll('.executor-item').forEach((item, index) => {
                    item.style.opacity = '0';
                    item.style.transform = 'translateX(-20px)';
                    setTimeout(() => {
                        item.style.transition = 'all 0.5s';
                        item.style.opacity = '1';
                        item.style.transform = 'translateX(0)';
                    }, index * 50);
                });
            }
        }

        function updateChart(executorStats) {
            const chartContainer = document.getElementById('chart-container');
            
            if (!executorStats || executorStats.length === 0) {
                chartContainer.innerHTML = '<p style="text-align: center; color: #999; padding: 50px;">Нет данных для отображения</p>';
                return;
            }
            
            const maxCount = Math.max(...executorStats.map(e => e.actual_count || 0));
            
            if (maxCount === 0) {
                chartContainer.innerHTML = '<p style="text-align: center; color: #999; padding: 50px;">Нет выполненных заявок</p>';
                return;
            }
            
            let chartHTML = '';
            executorStats.forEach((executor, index) => {
                const height = (executor.actual_count / maxCount) * 100;
                const colors = [
                    'linear-gradient(180deg, #667eea 0%, #764ba2 100%)',
                    'linear-gradient(180deg, #f093fb 0%, #f5576c 100%)',
                    'linear-gradient(180deg, #4facfe 0%, #00f2fe 100%)',
                    'linear-gradient(180deg, #fa709a 0%, #fee140 100%)',
                    'linear-gradient(180deg, #30cfd0 0%, #330867 100%)',
                    'linear-gradient(180deg, #a8edea 0%, #fed6e3 100%)',
                    'linear-gradient(180deg, #ff9a9e 0%, #fecfef 100%)'
                ];
                const color = colors[index % colors.length];
                
                chartHTML += `
                    <div class="chart-bar">
                        <div class="chart-bar-value">${executor.actual_count}</div>
                        <div class="chart-bar-column" style="height: ${height}%; background: ${color};"></div>
                        <div class="chart-bar-label">${executor.name}</div>
                    </div>
                `;
            });
            
            chartContainer.innerHTML = chartHTML;
        }

        // Функция для создания диаграммы прогресса выполнения
        function updateProgressChart(stats) {
            const progressChart = document.getElementById('progress-chart');
            
            if (!stats) {
                progressChart.innerHTML = '<p style="text-align: center; color: #999; padding: 50px;">Нет данных</p>';
                return;
            }

            const total = stats.total_requests || 0;
            const completed = stats.completed_requests || 0;
            const assigned = stats.assigned_requests || 0;
            const pending = stats.pending_requests || 0;
            
            if (total === 0) {
                progressChart.innerHTML = '<p style="text-align: center; color: #999; padding: 50px;">Нет заявок</p>';
                return;
            }

            const completionRate = Math.round((completed / total) * 100);
            const processingRate = Math.round(((completed + assigned) / total) * 100);
            const pendingRate = Math.round((pending / total) * 100);

            // Создаем круговую диаграмму прогресса
            const radius = 22;
            const circumference = 2 * Math.PI * radius;
            const completedOffset = circumference - (completionRate / 100) * circumference;
            const processingOffset = circumference - (processingRate / 100) * circumference;

            progressChart.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; gap: 8px; width: 100%;">
                    <div style="position: relative; width: 55px; height: 55px;">
                        <svg width="55" height="55" style="transform: rotate(-90deg);">
                            <!-- Фоновая окружность -->
                            <circle cx="27.5" cy="27.5" r="${radius}" stroke="#e5e7eb" stroke-width="3" fill="none"/>
                            <!-- Прогресс обработки -->
                            <circle cx="27.5" cy="27.5" r="${radius}" stroke="#3b82f6" stroke-width="3" fill="none" 
                                    stroke-dasharray="${circumference}" stroke-dashoffset="${processingOffset}" 
                                    stroke-linecap="round" style="transition: stroke-dashoffset 0.5s ease;"/>
                            <!-- Прогресс завершения -->
                            <circle cx="27.5" cy="27.5" r="${radius}" stroke="#10b981" stroke-width="3" fill="none" 
                                    stroke-dasharray="${circumference}" stroke-dashoffset="${completedOffset}" 
                                    stroke-linecap="round" style="transition: stroke-dashoffset 0.5s ease;"/>
                        </svg>
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
                            <div style="font-size: 12px; font-weight: 700; color: #10b981;">${completionRate}%</div>
                            <div style="font-size: 7px; color: #6b7280;">завершено</div>
                        </div>
                    </div>
                    
                    <div style="display: flex; flex-direction: column; gap: 8px; width: 100%;">
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: rgba(16, 185, 129, 0.1); border-radius: 6px;">
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <div style="width: 8px; height: 8px; background: #10b981; border-radius: 50%;"></div>
                                <span style="font-size: 12px; color: #374151;">Завершено</span>
                            </div>
                            <span style="font-weight: 600; color: #10b981; font-size: 12px;">${completed}</span>
                        </div>
                        
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: rgba(59, 130, 246, 0.1); border-radius: 6px;">
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <div style="width: 8px; height: 8px; background: #3b82f6; border-radius: 50%;"></div>
                                <span style="font-size: 12px; color: #374151;">В работе</span>
                            </div>
                            <span style="font-weight: 600; color: #3b82f6; font-size: 12px;">${assigned}</span>
                        </div>
                        
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: rgba(245, 158, 11, 0.1); border-radius: 6px;">
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <div style="width: 8px; height: 8px; background: #f59e0b; border-radius: 50%;"></div>
                                <span style="font-size: 12px; color: #374151;">Ожидают</span>
                            </div>
                            <span style="font-weight: 600; color: #f59e0b; font-size: 12px;">${pending}</span>
                        </div>
                    </div>
                </div>
            `;
        }


        // Функция для создания анализа производительности
        function updatePerformanceAnalysisChart(executorStats) {
            const performanceAnalysisChart = document.getElementById('performance-analysis-chart');
            
            if (!executorStats || executorStats.length === 0) {
                performanceAnalysisChart.innerHTML = '<p style="text-align: center; color: #999; padding: 50px;">Нет данных</p>';
                return;
            }

            // Анализируем производительность исполнителей
            const totalWork = executorStats.reduce((sum, e) => sum + (e.actual_count || 0), 0);
            const avgWork = totalWork / executorStats.length;
            
            const performanceData = executorStats.map(executor => {
                const work = executor.actual_count || 0;
                const efficiency = avgWork > 0 ? Math.round((work / avgWork) * 100) : 0;
                const status = efficiency >= 120 ? 'excellent' : efficiency >= 80 ? 'good' : efficiency >= 50 ? 'average' : 'poor';
                
                return {
                    name: executor.name,
                    work: work,
                    efficiency: efficiency,
                    status: status
                };
            });

            // Сортируем по эффективности
            performanceData.sort((a, b) => b.efficiency - a.efficiency);

            const getStatusColor = (status) => {
                switch (status) {
                    case 'excellent': return '#10b981';
                    case 'good': return '#3b82f6';
                    case 'average': return '#f59e0b';
                    case 'poor': return '#ef4444';
                    default: return '#6b7280';
                }
            };

            const getStatusIcon = (status) => {
                switch (status) {
                    case 'excellent': return '🚀';
                    case 'good': return '👍';
                    case 'average': return '⚡';
                    case 'poor': return '📉';
                    default: return '❓';
                }
            };

            const getStatusText = (status) => {
                switch (status) {
                    case 'excellent': return 'Отлично';
                    case 'good': return 'Хорошо';
                    case 'average': return 'Средне';
                    case 'poor': return 'Низко';
                    default: return 'Неизвестно';
                }
            };

            performanceAnalysisChart.innerHTML = `
                <div style="display: flex; flex-direction: column; gap: 3px; width: 100%;">
                    ${performanceData.slice(0, 3).map(executor => `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px; background: rgba(139, 92, 246, 0.05); border-radius: 3px; border-left: 2px solid ${getStatusColor(executor.status)};">
                            <div style="display: flex; align-items: center; gap: 4px;">
                                <span style="font-size: 10px;">${getStatusIcon(executor.status)}</span>
                                <div>
                                    <div style="font-weight: 600; color: #2d3748; font-size: 9px;">${executor.name}</div>
                                    <div style="color: #6b7280; font-size: 7px;">${executor.work} заявок</div>
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 10px; font-weight: 700; color: ${getStatusColor(executor.status)};">${executor.efficiency}%</div>
                                <div style="font-size: 7px; color: #6b7280;">${getStatusText(executor.status)}</div>
                            </div>
                        </div>
                    `).join('')}
                    
                    <div style="margin-top: 4px; padding: 6px; background: linear-gradient(135deg, #8b5cf6, #7c3aed); border-radius: 3px; color: white; text-align: center;">
                        <div style="font-size: 8px; font-weight: 600; margin-bottom: 1px;">Средняя эффективность</div>
                        <div style="font-size: 12px; font-weight: 700;">${Math.round(performanceData.reduce((sum, e) => sum + e.efficiency, 0) / performanceData.length)}%</div>
                    </div>
                </div>
            `;
        }

        // Функция для анимации процесса одобрения заявки
        function animateRequestMovement(requestId, newStatus) {
            const list = document.getElementById('requests-list');
            if (!list) {
                console.warn('Элемент requests-list не найден');
                return;
            }
            const requestItems = list.querySelectorAll('.request-item');
            
            // Ищем заявку по ID
            let foundItem = null;
            requestItems.forEach(item => {
                const strongElement = item.querySelector('strong');
                if (strongElement && strongElement.textContent) {
                    const itemId = strongElement.textContent.match(/#(\d+)/);
                    if (itemId && parseInt(itemId[1]) === requestId) {
                        foundItem = item;
                    }
                }
            });
            
            if (!foundItem) {
                // Не выводим предупреждения для заявок, которые еще не попали в список
                return;
            }
            
            if (foundItem) {
                // Добавляем класс анимации
                foundItem.classList.add('moving');
                
                // Создаем индикатор процесса одобрения
                const approvalIndicator = document.createElement('div');
                approvalIndicator.style.cssText = `
                    position: absolute;
                    top: 5px;
                    right: 10px;
                    background: rgba(0,0,0,0.1);
                    padding: 2px 8px;
                    border-radius: 10px;
                    font-size: 0.7em;
                    color: #666;
                    z-index: 10;
                `;
                approvalIndicator.textContent = 'Одобрение...';
                foundItem.style.position = 'relative';
                foundItem.appendChild(approvalIndicator);
                
                // Обновляем статус поэтапно
                const statusText = {
                    'pending': '⏳ Ожидает',
                    'assigned': '📋 Назначена',
                    'completed': '✅ Завершена'
                };
                
                const statusDiv = foundItem.querySelector('div');
                if (statusDiv) {
                    // Показываем процесс одобрения
                    const approvalSteps = [
                        '🔄 Проверка данных...',
                        '📋 Назначение исполнителя...',
                        '⚡ Обработка...',
                        '✅ Одобрено!'
                    ];
                    
                    let stepIndex = 0;
                    const stepInterval = setInterval(() => {
                        if (stepIndex < approvalSteps.length) {
                            statusDiv.innerHTML = `Статус: ${approvalSteps[stepIndex]}`;
                            stepIndex++;
                        } else {
                            clearInterval(stepInterval);
                            statusDiv.innerHTML = `Статус: ${statusText[newStatus]}`;
                        }
                    }, 15);
                }
                
                // Удаляем элемент после завершения анимации
                setTimeout(() => {
                    if (foundItem.parentNode) {
                        foundItem.parentNode.removeChild(foundItem);
                    }
                }, 300); // 0.3 секунды для полного процесса одобрения
            } else {
                // Если заявка не найдена в списке, анимируем первую заявку
                if (requestItems.length > 0) {
                    const firstItem = requestItems[0];
                    console.log(`Заявка #${requestId} не найдена, запускаем процесс одобрения для первой заявки`);
                    
                    firstItem.classList.add('moving');
                    firstItem.style.position = 'relative';
                    
                    const approvalIndicator = document.createElement('div');
                    approvalIndicator.style.cssText = `
                        position: absolute;
                        top: 5px;
                        right: 10px;
                        background: rgba(0,0,0,0.1);
                        padding: 2px 8px;
                        border-radius: 10px;
                        font-size: 0.7em;
                        color: #666;
                        z-index: 10;
                    `;
                    approvalIndicator.textContent = 'Одобрение...';
                    firstItem.appendChild(approvalIndicator);
                    
                    const statusText = {
                        'pending': '⏳ Ожидает',
                        'assigned': '📋 Назначена',
                        'completed': '✅ Завершена'
                    };
                    
                    const statusDiv = firstItem.querySelector('div');
                    if (statusDiv) {
                        const approvalSteps = [
                            '🔄 Проверка данных...',
                            '📋 Назначение исполнителя...',
                            '⚡ Обработка...',
                            '✅ Одобрено!'
                        ];
                        
                        let stepIndex = 0;
                        const stepInterval = setInterval(() => {
                            if (stepIndex < approvalSteps.length) {
                                statusDiv.innerHTML = `Статус: ${approvalSteps[stepIndex]}`;
                                stepIndex++;
                            } else {
                                clearInterval(stepInterval);
                                statusDiv.innerHTML = `Статус: ${statusText[newStatus]}`;
                            }
                        }, 15);
                    }
                    
                    setTimeout(() => {
                        if (firstItem.parentNode) {
                            firstItem.parentNode.removeChild(firstItem);
                        }
                    }, 300);
                }
            }
        }


        async function loadRecentRequests() {
            try {
                const response = await fetch(`${API_BASE}/requests/recent/30`);
                const requests = await response.json();
                
                const list = document.getElementById('requests-list');
                
                if (requests.length === 0) {
                    list.innerHTML = '<p style="text-align: center; color: #999;">Нет заявок</p>';
                    stopCyclicAnimation();
                    return;
                }
                
                let newHTML = '';
                requests.forEach(request => {
                    const statusText = {
                        'pending': '⏳ Ожидает',
                        'assigned': '📋 Назначена',
                        'completed': '✅ Завершена'
                    };
                    
                    const executorName = request.assigned_to ? ` → Исполнитель ${request.assigned_to}` : '';
                    
                    // Форматируем параметры для лучшего отображения
                    let paramsText = '';
                    if (request.parameters) {
                        const params = [];
                        if (request.parameters.city) {
                            params.push(`Город: ${request.parameters.city}`);
                        }
                        if (request.parameters.data_type) {
                            const dataTypeNames = {
                                'raster': 'Растровые',
                                'numeric': 'Числовые', 
                                'text': 'Текстовые'
                            };
                            params.push(`Тип: ${dataTypeNames[request.parameters.data_type] || request.parameters.data_type}`);
                        }
                        if (request.type) {
                            params.push(`Приоритет: ${request.type}`);
                        }
                        if (request.customer_id) {
                            params.push(`Клиент: ${request.customer_id}`);
                        }
                        if (request.value) {
                            params.push(`Сумма: ${request.value}`);
                        }
                        paramsText = params.join(' | ');
                    }
                    
                    newHTML += `
                        <div class="request-item ${request.status}">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <strong>#${request.id}</strong>
                                <span style="font-size: 0.8em; color: #666;">${statusText[request.status]}</span>
                            </div>
                            <div style="font-size: 0.8em; color: #999; margin-top: 3px;">
                                ${paramsText || JSON.stringify(request.parameters || {}).substring(0, 40) + '...'}
                            </div>
                        </div>
                    `;
                });
                
                list.innerHTML = newHTML;
                
                // Запускаем цикличную анимацию
                startCyclicAnimation();
                
            } catch (error) {
                console.error('Ошибка загрузки заявок:', error);
            }
        }
        
        let animationInterval = null;
        
        function startCyclicAnimation() {
            const list = document.getElementById('requests-list');
            
            function animateItems() {
                const items = list.querySelectorAll('.request-item');
                
                // Проверяем, есть ли заявки для анимации
                if (items.length === 0) {
                    console.log('[DEBUG] Нет заявок для анимации');
                    return;
                }
                
                // Сначала сбрасываем все заявки
                items.forEach((item) => {
                    item.style.opacity = '0';
                    item.style.transform = 'translateY(-20px)';
                });
                
                // Затем анимируем с волновым эффектом, но с одинаковыми интервалами
                setTimeout(() => {
                    items.forEach((item, index) => {
                        setTimeout(() => {
                            item.style.transition = 'all 0.4s ease';
                            item.style.opacity = '1';
                            item.style.transform = 'translateY(0)';
                        }, index * 20); // Одинаковая задержка 20ms между заявками
                    });
                }, 50); // Небольшая задержка перед началом анимации
            }
            
            // Останавливаем предыдущую анимацию если есть
            if (animationInterval) {
                clearInterval(animationInterval);
            }
            
            // Запускаем анимацию сразу
            animateItems();
            
            // Повторяем анимацию каждые 1.5 секунды (быстрее для 30 заявок)
            animationInterval = setInterval(animateItems, 1500);
        }
        
        function stopCyclicAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        }
        
        // Функция для создания заявок в фоне
        function startBackgroundRequestCreation() {
            setInterval(async () => {
                try {
                    const statsRes = await fetch(`${API_BASE}/stats`);
                    const stats = await statsRes.json();
                    
                    // Если заявок меньше 30, создаем еще
                    if (stats.pending_requests + stats.assigned_requests < 30) {
                        await createRandomRequests();
                    }
                } catch (error) {
                    // Игнорируем ошибки
                }
            }, 1000); // Каждую секунду проверяем
        }

        function showExecutorModal() {
            const modal = document.getElementById('executor-modal');
            if (modal) {
                modal.style.display = 'flex';
            }
        }
        
        function closeExecutorModal() {
            const modal = document.getElementById('executor-modal');
            modal.style.display = 'none';
            // Очищаем поля
            document.getElementById('executor-name').value = '';
            document.getElementById('executor-city').value = '';
            document.getElementById('executor-data-type').value = '';
        }
        
        async function createExecutorFromModal() {
            const name = document.getElementById('executor-name').value.trim();
            const city = document.getElementById('executor-city').value;
            const dataType = document.getElementById('executor-data-type').value;
            
            
            if (!name) {
                console.log('[ERROR] Введите имя исполнителя!');
                return;
            }
            
            try {
                const executorData = { name };
                if (city) {
                    executorData.city = city;
                }
                if (dataType) {
                    executorData.data_type = dataType;
                }
                
                const response = await fetch(`${API_BASE}/executors/`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(executorData)
                });
                
                if (response.ok) {
                    closeExecutorModal();
                    loadStats();
                    console.log('[INFO] Исполнитель создан!');
                } else {
                    const errorText = await response.text();
                    console.log('[ERROR] Ошибка создания исполнителя:', response.status, errorText);
                }
            } catch (error) {
                console.log('[ERROR] Ошибка: ' + error.message);
            }
        }
        
        function createExecutor() {
            showExecutorModal();
        }

        // Функции для выпадающего меню создания заявок
        function toggleCreateDropdown() {
            const dropdown = document.getElementById('create-dropdown');
            dropdown.classList.toggle('show');
        }

        function hideCreateDropdown() {
            const dropdown = document.getElementById('create-dropdown');
            dropdown.classList.remove('show');
        }

        // Функции для модального окна удаления
        let executorToDelete = null;

        function showDeleteModal(executorId, executorName) {
            executorToDelete = executorId;
            document.getElementById('delete-executor-name').textContent = executorName;
            document.getElementById('delete-modal').style.display = 'flex';
        }

        function closeDeleteModal() {
            document.getElementById('delete-modal').style.display = 'none';
            executorToDelete = null;
        }

        async function confirmDeleteExecutor() {
            if (!executorToDelete) return;

            try {
                const response = await fetch(`${API_BASE}/executors/${executorToDelete}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    console.log('[INFO] Исполнитель удален!');
                    closeDeleteModal();
                    loadStats(); // Обновляем статистику
                } else {
                    const errorText = await response.text();
                    console.log('[ERROR] Ошибка удаления исполнителя:', response.status, errorText);
                }
            } catch (error) {
                console.log('[ERROR] Ошибка: ' + error.message);
            }
        }

        function deleteExecutor(executorId) {
            // Находим имя исполнителя для отображения в модальном окне
            const executorItems = document.querySelectorAll('.executor-item');
            let executorName = 'исполнителя';
            
            for (let item of executorItems) {
                const button = item.querySelector(`button[onclick*="${executorId}"]`);
                if (button) {
                    const nameElement = item.querySelector('strong');
                    if (nameElement) {
                        executorName = nameElement.textContent;
                    }
                    break;
                }
            }
            
            showDeleteModal(executorId, executorName);
        }

        async function createRandomRequests() {
            try {
                // Получаем текущую статистику
                const statsRes = await fetch(`${API_BASE}/stats`);
                const stats = await statsRes.json();
                
                // Создаем заявки если их меньше 100 (еще больше для бесконечной работы)
                if (stats.pending_requests + stats.assigned_requests >= 100) {
                    return;
                }
                
                const requests = [];
                const types = ['urgent', 'normal', 'low'];
                const cities = ['Москва', 'Санкт-Петербург', 'Новосибирск', 'Екатеринбург', 'Казань'];
                const dataTypes = ['raster', 'numeric', 'text'];
                
                // Создаем 5-12 заявок за раз (еще больше для бесконечной работы)
                const requestsToCreate = Math.floor(Math.random() * 8) + 5;
                
                for (let i = 0; i < requestsToCreate; i++) {
                    requests.push({
                        type: types[Math.floor(Math.random() * types.length)],
                        customer_id: Math.floor(Math.random() * 9000) + 1000,
                        value: Math.floor(Math.random() * 50000) + 100,
                        parameters: {
                            city: cities[Math.floor(Math.random() * cities.length)],
                            data_type: dataTypes[Math.floor(Math.random() * dataTypes.length)]
                        }
                    });
                }
                
                const response = await fetch(`${API_BASE}/requests/bulk/`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({requests})
                });
                
                if (response.ok) {
                    console.log(`[INFO] Создано ${requestsToCreate} заявок!`);
                    // Принудительно обновляем заявки для анимации
                    setTimeout(() => {
                        loadRecentRequests();
                    }, 100);
                } else {
                    console.log('[ERROR] Ошибка создания заявок:', response.status);
                }
            } catch (error) {
                console.log('[ERROR] Ошибка: ' + error.message);
            }
        }

async function createMassiveRequests() {
    try {
        const requests = [];
        const types = ['urgent', 'normal', 'low'];
        
        for (let i = 0; i < 1000; i++) {
            requests.push({
                type: types[Math.floor(Math.random() * types.length)],
                customer_id: Math.floor(Math.random() * 9000) + 1000,
                value: Math.floor(Math.random() * 50000) + 100
            });
        }
        
        const response = await fetch(`${API_BASE}/requests/bulk/`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({requests})
        });
        
        if (response.ok) {
            loadStats();
            console.log('[INFO] Создано 1000 заявок!');
        } else {
            console.log('[ERROR] Ошибка создания заявок');
        }
    } catch (error) {
        console.log('[ERROR] Ошибка: ' + error.message);
    }
}

async function createContinuousRequests() {
    try {
        const requests = [];
        const types = ['urgent', 'normal', 'low'];
        
        for (let i = 0; i < 10000; i++) {
            requests.push({
                type: types[Math.floor(Math.random() * types.length)],
                customer_id: Math.floor(Math.random() * 9000) + 1000,
                value: Math.floor(Math.random() * 50000) + 100
            });
        }
        
        const response = await fetch(`${API_BASE}/requests/bulk/`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({requests})
        });
        
        if (response.ok) {
            loadStats();
            console.log('[INFO] Создано 10000 заявок!');
        } else {
            console.log('[ERROR] Ошибка создания заявок');
        }
    } catch (error) {
        console.log('[ERROR] Ошибка: ' + error.message);
    }
}

async function clearAllRequests() {
    if (!confirm('Вы уверены, что хотите удалить ВСЕ заявки? Это действие нельзя отменить!')) {
        return;
    }
    
    try {
        const response = await fetch(`${API_BASE}/requests/clear`, {
            method: 'DELETE'
        });
        
        if (response.ok) {
            loadStats();
            console.log('[INFO] Все заявки удалены!');
        } else {
            console.log('[ERROR] Ошибка удаления заявок');
        }
    } catch (error) {
        console.log('[ERROR] Ошибка: ' + error.message);
    }
}

        async function distributeRequests() {
            try {
                const executorsRes = await fetch(`${API_BASE}/executors/`);
                const executors = await executorsRes.json();
                
                if (executors.length === 0) {
                    return;
                }
                
                const activeExecutors = executors.filter(e => e.is_active);
                // Распределяем по 5 заявок на исполнителя за цикл (больше для непрерывной работы)
                for (let i = 0; i < 5; i++) {
                    for (const executor of activeExecutors) {
                        try {
                            const response = await fetch(`${API_BASE}/executors/${executor.id}/get-next-request`, {
                                method: 'POST'
                            });
                            
                            // Если заявка получена, сразу завершаем её для непрерывной работы
                            if (response.ok) {
                                const requestData = await response.json();
                                if (requestData) {
                                    // Показываем анимацию движения заявки к исполнителю
                                    animateRequestMovement(requestData.id, 'assigned');
                                    
                                    // Завершаем заявку через 200ms для имитации обработки
                                    setTimeout(async () => {
                                        try {
                                            await fetch(`${API_BASE}/requests/${requestData.id}/complete`, {
                                                method: 'POST',
                                                headers: {'Content-Type': 'application/json'},
                                                body: JSON.stringify({result: `Completed by ${executor.name}`})
                                            });
                                            // Увеличиваем счетчик обработанных заявок
                                            incrementProcessedRequests();
                                            // Показываем анимацию завершения заявки
                                            setTimeout(() => {
                                                animateRequestMovement(requestData.id, 'completed');
                                            }, 50);
                                        } catch (e) {
                                            // Игнорируем ошибки завершения
                                        }
                                    }, 50);
                                }
                            }
                        } catch (e) {
                            // Игнорируем ошибки для продолжения работы
                        }
                    }
                }
                
            } catch (error) {
                console.log('[ERROR] Ошибка при распределении: ' + error.message);
            }
        }

        async function completeRandomRequests() {
            try {
                // Получаем статистику
                const statsRes = await fetch(`${API_BASE}/stats`);
                const stats = await statsRes.json();
                
                // Если есть назначенные заявки, завершаем только 1-2 случайных (еще меньше для бесконечной работы)
                if (stats.assigned_requests > 0) {
                    const numToComplete = Math.min(Math.floor(Math.random() * 2) + 1, stats.assigned_requests);
                    
                    for (let i = 0; i < numToComplete; i++) {
                        try {
                            // Получаем случайную назначенную заявку
                            const requestsRes = await fetch(`${API_BASE}/requests/recent/100`);
                            const requests = await requestsRes.json();
                            const assignedRequests = requests.filter(r => r.status === 'assigned');
                            
                            if (assignedRequests.length > 0) {
                                const randomRequest = assignedRequests[Math.floor(Math.random() * assignedRequests.length)];
                                await fetch(`${API_BASE}/requests/${randomRequest.id}/complete`, {
                                    method: 'POST'
                                });
                                // Увеличиваем счетчик обработанных заявок
                                incrementProcessedRequests();
                            }
                        } catch (e) {
                            // Игнорируем ошибки завершения
                        }
                    }
                }
            } catch (error) {
                // Игнорируем ошибки
            }
        }

        function toggleAutoRefresh() {
            const checkbox = document.getElementById('auto-refresh');
            if (checkbox.checked) {
                autoRefreshInterval = setInterval(async () => {
                    try {
                        // Сначала получаем статистику
                        const statsRes = await fetch(`${API_BASE}/stats`);
                        const stats = await statsRes.json();
                        
                        // Если есть ожидающие заявки, распределяем их
                        if (stats.pending_requests > 0) {
                            await distributeRequests();
                        }
                        
                        // Завершаем случайные заявки для демонстрации
                        await completeRandomRequests();
                        
                        // Создаем новые заявки еще чаще для бесконечной работы
                        if (stats.pending_requests + stats.assigned_requests < 100 && Math.random() < 0.9) { // 90% вероятность
                            await createRandomRequests();
                        }
                        
                        // Обновляем статистику
                        await loadStats();
                        
                        // Проверяем, нужно ли остановить анимацию
                        if (stats.pending_requests + stats.assigned_requests === 0) {
                            stopCyclicAnimation();
                        }
                        
                        // Принудительно создаем заявки если их становится слишком мало
                        if (stats.pending_requests + stats.assigned_requests < 20) {
                            await createRandomRequests();
                            await createRandomRequests();
                        }
                        
                    } catch (error) {
                        console.log('[ERROR] Ошибка в автообновлении: ' + error.message);
                    }
                }, 200);
                console.log('Автообновление включено');
            } else {
                clearInterval(autoRefreshInterval);
                console.log('Автообновление выключено');
            }
        }

        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.match(/\.(xlsx|xls)$/)) {
                console.log('[WARN] Пожалуйста, выберите файл Excel (.xlsx или .xls)');
                return;
            }
            
            try {
                const formData = new FormData();
                formData.append('file', file);
                
                const response = await fetch(`${API_BASE}/upload/excel`, {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('[INFO] ' + result.message);
                    loadStats();
                } else {
                    const error = await response.json();
                    console.log('[ERROR] Ошибка: ' + error.detail);
                }
            } catch (error) {
                console.log('[ERROR] Ошибка загрузки: ' + error.message);
            }
            
            event.target.value = '';
        }

        loadStats();

        // Закрытие модального окна при клике вне его
        window.onclick = function(event) {
            const executorModal = document.getElementById('executor-modal');
            const deleteModal = document.getElementById('delete-modal');
            const createDropdown = document.getElementById('create-dropdown');
            
            if (event.target === executorModal) {
                closeExecutorModal();
            }
            
            if (event.target === deleteModal) {
                closeDeleteModal();
            }
            
            // Закрываем выпадающее меню при клике вне его
            if (!event.target.matches('.dropdown-toggle') && !event.target.closest('.dropdown')) {
                hideCreateDropdown();
            }
        }

        // Закрытие модального окна по клавише Escape
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const executorModal = document.getElementById('executor-modal');
                const deleteModal = document.getElementById('delete-modal');
                const createDropdown = document.getElementById('create-dropdown');
                
                if (executorModal.style.display === 'flex') {
                    closeExecutorModal();
                }
                
                if (deleteModal.style.display === 'flex') {
                    closeDeleteModal();
                }
                
                if (createDropdown.classList.contains('show')) {
                    hideCreateDropdown();
                }
            }
        });
    </script>

    <!-- Модальное окно для создания исполнителя -->
    <div id="executor-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeExecutorModal()">&times;</span>
            <h3>Добавить исполнителя</h3>
            
            <div class="form-group">
                <label for="executor-name">Имя исполнителя:</label>
                <input type="text" id="executor-name" placeholder="Например: Executor-1" required>
            </div>
            
            <div class="form-group">
                <label for="executor-city">Город (опционально):</label>
                <select id="executor-city">
                    <option value="">Выберите город</option>
                    <option value="Москва">Москва</option>
                    <option value="Санкт-Петербург">Санкт-Петербург</option>
                    <option value="Новосибирск">Новосибирск</option>
                    <option value="Екатеринбург">Екатеринбург</option>
                    <option value="Казань">Казань</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="executor-data-type">Тип данных (опционально):</label>
                <select id="executor-data-type">
                    <option value="">Выберите тип данных</option>
                    <option value="raster">Растровые</option>
                    <option value="numeric">Числовые</option>
                    <option value="text">Текстовые</option>
                </select>
            </div>
            
            <div class="btn-group">
                <button class="btn btn-primary" onclick="createExecutorFromModal()">Создать</button>
                <button class="btn btn-warning" onclick="closeExecutorModal()">Отмена</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно для подтверждения удаления -->
    <div id="delete-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeDeleteModal()">&times;</span>
            <h3>Подтверждение удаления</h3>
            
            <div class="modal-body">
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 3em; color: #dc3545; margin-bottom: 10px;">⚠️</div>
                    <p>Вы уверены, что хотите удалить исполнителя <strong id="delete-executor-name"></strong>?</p>
                </div>
                <p class="warning-block">
                    Это действие нельзя отменить. Все назначенные заявки будут переназначены другим исполнителям.
                </p>
            </div>
            
            <div class="btn-group">
                <button class="btn btn-danger" onclick="confirmDeleteExecutor()">Удалить</button>
                <button class="btn btn-warning" onclick="closeDeleteModal()">Отмена</button>
            </div>
        </div>
    </div>
</body>
</html>

